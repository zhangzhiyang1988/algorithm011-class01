学习笔记
哈希表 Hash table
• 哈希函数：用来映射，关键码映到哈希表中的位置
• 哈希表：存放记录
• 
工程实践
• 电话号码簿
• 用户信息表
• 缓存 LRU Cache
• 键值对存储 Redis
哈希碰撞 Hash Collisions
• 不同的关键码映射到同一个值
o 哈希表的大小
o 哈希函数的效率
• 拉链式解决冲突法：哈希表用来存放链表，存放冲突的多个元素
复杂度分析
• 理想情况：查询/插入/删除：常数级
• 最坏情况：线性复杂度
o 取决于哈希冲突的概率
o 坏情况下哈希表退化成红黑树，链表
Java中运用哈希表实现
• HashMap
o 键值对，key不重复
• HashSet
o 不重复的元素集合
HashMap小总结
简单情况下，HashMap底层由一个tab数组储存内部类Node<K,V>实现。
put
• 运用哈希算法得到key的哈希值，以此为下标将整个Node存入tab。常数复杂度。
• 如果存在哈希值冲突，则以链表/红黑树的结构储存冲突的多个Node。这时候需要遍历链表/红黑树，将新的Node存入尾部。
• 一开始用链表解决冲突，当链表大于一定长度，将它黑红树化
get
• 运用哈希算法得到key的哈希值，以此为下标直接提取Node，常数复杂度。
• 如果该下标储存了多个Node，则需要遍历链表/红黑树，提取key相等的Node。
树
• 二维数据结构
• 链表是一种特殊的树，树的每个节点只有一个子节点
• 树是一种特殊的图，图内没有环
树的节点构造
• value
• leftNode
• rightNode
树与下棋
• 每一种棋类可以抽象成由所有可能情况组成的状态树或决策树
• 状态空间越复杂，棋的难度越大
二叉树的遍历
• 前序遍历：NLR
• 中序遍历：LNR
• 后序遍历：LRN
• O(n)
二叉搜索树
• 左子树的所有节点小于根节点，右子树的所有节点大于根节点
• 重复性
• 中序遍历：升序排列
二叉搜索树常见操作
• 查询：O(logn)
• 插入：O(logn)
• 删除：O(logn)
为什么树的面试题都是递归？
• 一般情况下，对树进行递归的操作是最简洁优雅的
• 写出正确的递归代码，体现一个程序员的基本功
堆
• 特性：迅速找到一堆数中的最大/小值
• 常见：二叉堆，斐波那契堆
• 常见操作：
o 找最值：O(1)
o 删除最值：O(logN)
o 插入：O(logN) or O(1)斐波那契堆
• 可以把堆看作一个接口，有多种实现
二叉堆
• 实现相对容易，性能相对较差
• 通过完全二叉树实现二叉堆
• 大顶二叉堆性质：
o 一棵完全树
o 任意节点值>=子节点的值
二叉堆实现细节
• 数组实现（因为是完全树）
• 根的下标为0，层序依次放入数组
• 某节点下标为i
o 左子节点下标：2*i+1
o 右子节点下标：2*i+2
o 父节点下标：floor((i-1)/2)
• 插入：O(logN)
i. 新元素插入尾部
ii. 依次向上堆化-HeapifyUp
• 删除堆顶：O(logN)
 . 用堆尾元素替换顶部
i. 依次向下堆化-HeapifyDown
• Java中优先队列PriorityQueue是二叉堆的实现，但并不是最优实现

